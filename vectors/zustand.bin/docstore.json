[["0",{"pageContent":"---\ntitle: Comparison\ndescription: How Zustand stacks up against similar libraries\nnav: 1\n---\n\nZustand is one of many state management libraries for React.\nOn this page we will discuss Zustand\nin comparison to some of these libraries,\nincluding Redux, Valtio, Jotai, and Recoil.\n\nEach library has its own strengths and weaknesses,\nand we will compare key differences and similarities between each.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":1,"to":13}}}}],["1",{"pageContent":"Redux","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":13,"to":13}}}}],["2",{"pageContent":"State Model\n\nConceptually, Zustand and Redux are quite similar,\nboth are based on an immutable state model.\nHowever, Redux requires your app to be wrapped\nin context providers; Zustand does not.\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  increment: (qty: number) => set((state) => ({ count: state.count + qty })),\n  decrement: (qty: number) => set((state) => ({ count: state.count - qty })),\n}))","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":20,"to":43}}}}],["3",{"pageContent":"```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\ntype Action = {\n  type: keyof Actions\n  qty: number\n}\n\nconst countReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + action.qty }\n    case 'decrement':\n      return { count: state.count - action.qty }\n    default:\n      return state\n  }\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  dispatch: (action: Action) => set((state) => countReducer(state, action)),\n}))","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":46,"to":77}}}}],["4",{"pageContent":"```ts\nimport { createStore } from 'redux'\nimport { useSelector, useDispatch } from 'react-redux'\n\ntype State = {\n  count: number\n}\n\ntype Action = {\n  type: 'increment' | 'decrement'\n  qty: number\n}\n\nconst countReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + action.qty }\n    case 'decrement':\n      return { count: state.count - action.qty }\n    default:\n      return state\n  }\n}\n\nconst countStore = createStore(countReducer)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":80,"to":104}}}}],["5",{"pageContent":"```ts\nimport { createSlice, configureStore } from '@reduxjs/toolkit'\n\nconst countSlice = createSlice({\n  name: 'count',\n  initialState: { value: 0 },\n  reducers: {\n    incremented: (state, qty: number) => {\n      // Redux Toolkit does not mutate the state, it uses the Immer library\n      // behind scenes, allowing us to have something called \"draft state\".\n      state.value += qty\n    },\n    decremented: (state, qty: number) => {\n      state.value -= qty\n    },\n  },\n})\n\nconst countStore = configureStore({ reducer: countSlice.reducer })\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":107,"to":126}}}}],["6",{"pageContent":"Render Optimization\n\nWhen it comes to render optimizations within your app,\nthere are no major differences in approach between Zustand and Redux.\nIn both libraries it is recommended\nthat you manually apply render optimizations by using selectors.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  increment: (qty: number) => set((state) => ({ count: state.count + qty })),\n  decrement: (qty: number) => set((state) => ({ count: state.count - qty })),\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  const increment = useCountStore((state) => state.increment)\n  const decrement = useCountStore((state) => state.decrement)\n  // ...\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":128,"to":160}}}}],["7",{"pageContent":"**Redux**\n\n```ts\nimport { createStore } from 'redux'\nimport { useSelector, useDispatch } from 'react-redux'\n\ntype State = {\n  count: number\n}\n\ntype Action = {\n  type: 'increment' | 'decrement'\n  qty: number\n}\n\nconst countReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + action.qty }\n    case 'decrement':\n      return { count: state.count - action.qty }\n    default:\n      return state\n  }\n}\n\nconst countStore = createStore(countReducer)\n\nconst Component = () => {\n  const count = useSelector((state) => state.count)\n  const dispatch = useDispatch()\n  // ...\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":163,"to":195}}}}],["8",{"pageContent":"```ts\nimport { useSelector } from 'react-redux'\nimport type { TypedUseSelectorHook } from 'react-redux'\nimport { createSlice, configureStore } from '@reduxjs/toolkit'\n\nconst countSlice = createSlice({\n  name: 'count',\n  initialState: { value: 0 },\n  reducers: {\n    incremented: (state, qty: number) => {\n      // Redux Toolkit does not mutate the state, it uses the Immer library\n      // behind scenes, allowing us to have something called \"draft state\".\n      state.value += qty\n    },\n    decremented: (state, qty: number) => {\n      state.value -= qty\n    },\n  },\n})\n\nconst countStore = configureStore({ reducer: countSlice.reducer })\n\nconst useAppSelector: TypedUseSelectorHook<typeof countStore.getState> =\n  useSelector\n\nconst useAppDispatch: () => typeof countStore.dispatch = useDispatch\n\nconst Component = () => {\n  const count = useAppSelector((state) => state.count.value)\n  const dispatch = useAppDispatch()\n  // ...\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":198,"to":230}}}}],["9",{"pageContent":"Valtio\n\n### State Model\n\nZustand and Valtio approach state management\nin a fundamentally different way.\nZustand is based on the **immutable** state model,\nwhile Valtio is based on the **mutable** state model.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  obj: { count: number }\n}\n\nconst store = create<State>(() => ({ obj: { count: 0 } }))\n\nstore.setState((prev) => ({ obj: { count: prev.obj.count + 1 } }))\n```\n\n**Valtio**\n\n```ts\nimport { proxy } from 'valtio'\n\nconst state = proxy({ obj: { count: 0 } })\n\nstate.obj.count += 1\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":232,"to":263}}}}],["10",{"pageContent":"Render Optimization\n\nThe other difference between Zustand and Valtio\nis Valtio makes render optimizations through property access.\nHowever, with Zustand, it is recommended that\nyou manually apply render optimizations by using selectors.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\nconst useCountStore = create<State>(() => ({\n  count: 0,\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  // ...\n}\n```\n\n**Valtio**\n\n```ts\nimport { proxy, useSnapshot } from 'valtio'\n\nconst state = proxy({\n  count: 0,\n})\n\nconst Component = () => {\n  const { count } = useSnapshot(state)\n  // ...\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":265,"to":304}}}}],["11",{"pageContent":"Jotai\n\n### State Model\n\nThere are two major differences between Zustand and Jotai.\nFirstly, Zustand is a single store,\nwhile Jotai consists of primitive atoms\nthat can be composed together.\nSecondly, a Zustand store is an external store,\nmaking it more suitable when access outside of React is required.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  updateCount: (\n    countCallback: (count: State['count']) => State['count']\n  ) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  updateCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n```\n\n**Jotai**\n\n```ts\nimport { atom } from 'jotai'\n\nconst countAtom = atom<number>(0)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":306,"to":345}}}}],["12",{"pageContent":"Render Optimization\n\nJotai achieves render optimizations through atom dependency.\nHowever, with Zustand it is recommended that\nyou manually apply render optimizations by using selectors.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  updateCount: (\n    countCallback: (count: State['count']) => State['count']\n  ) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  updateCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  const updateCount = useCountStore((state) => state.updateCount)\n  // ...\n}\n```\n\n**Jotai**\n\n```ts\nimport { atom, useAtom } from 'jotai'\n\nconst countAtom = atom<number>(0)\n\nconst Component = () => {\n  const [count, updateCount] = useAtom(countAtom)\n  // ...\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":347,"to":392}}}}],["13",{"pageContent":"Recoil\n\n### State Model\n\nThe difference between Zustand and Recoil\nis similar to that between Zustand and Jotai.\nRecoil depends on atom string keys\ninstead of atom object referential identities.\nAdditionally, Recoil needs to wrap your app in a context provider.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  setCount: (countCallback: (count: State['count']) => State['count']) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  setCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n```\n\n**Recoil**\n\n```ts\nimport { atom } from 'recoil'\n\nconst count = atom({\n  key: 'count',\n  default: 0,\n})\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":394,"to":433}}}}],["14",{"pageContent":"Render Optimization\n\nSimilar to previous optimization comparisons,\nRecoil makes render optimizations through atom dependency.\nWhereas with Zustand, it is recommended that\nyou manually apply render optimizations by using selectors.\n\n**Zustand**\n\n```ts\nimport { create } from 'zustand'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  setCount: (countCallback: (count: State['count']) => State['count']) => void\n}\n\nconst useCountStore = create<State & Actions>((set) => ({\n  count: 0,\n  setCount: (countCallback) =>\n    set((state) => ({ count: countCallback(state.count) })),\n}))\n\nconst Component = () => {\n  const count = useCountStore((state) => state.count)\n  const setCount = useCountStore((state) => state.setCount)\n  // ...\n}\n```\n\n**Recoil**\n\n```ts\nimport { atom, useRecoilState } from 'recoil'\n\nconst countAtom = atom({\n  key: 'count',\n  default: 0,\n})\n\nconst Component = () => {\n  const [count, setCount] = useRecoilState(countAtom)\n  // ...\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/comparison.md","loc":{"lines":{"from":435,"to":482}}}}],["15",{"pageContent":"---\ntitle: Introduction\ndescription: How to use Zustand\nnav: 0\n---\n\n<div class=\"flex justify-center mb-4\">\n  <img src=\"https://github.com/pmndrs/zustand/raw/main/bear.jpg\" />\n</div>\n\nA small, fast, and scalable bearbones state management solution.\nZustand has a comfy API based on hooks.\nIt isn't boilerplatey or opinionated,\nbut has enough convention to be explicit and flux-like.\n\nDon't disregard it because it's cute, it has claws!\nLots of time was spent to deal with common pitfalls,\nlike the dreaded [zombie child problem],\n[React concurrency], and [context loss]\nbetween mixed renderers.\nIt may be the one state manager in the React space that gets all of these right.\n\nYou can try a live demo [here](https://codesandbox.io/s/dazzling-moon-itop4).","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/introduction.md","loc":{"lines":{"from":1,"to":23}}}}],["16",{"pageContent":"You can try a live demo [here](https://codesandbox.io/s/dazzling-moon-itop4).\n\n[zombie child problem]: https://react-redux.js.org/api/hooks#stale-props-and-zombie-children\n[react concurrency]: https://github.com/bvaughn/rfcs/blob/useMutableSource/text/0000-use-mutable-source.md\n[context loss]: https://github.com/facebook/react/issues/13332","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/introduction.md","loc":{"lines":{"from":23,"to":27}}}}],["17",{"pageContent":"Installation\n\nZustand is available as a package on NPM for use:\n\n```bash\n# NPM\nnpm install zustand\n\n# Yarn\nyarn add zustand\n```\n\n## First create a store\n\nYour store is a hook!\nYou can put anything in it: primitives, objects, functions.\nThe `set` function _merges_ state.\n\n```js\nimport { create } from 'zustand'\n\nconst useStore = create((set) => ({\n  bears: 0,\n  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n  removeAllBears: () => set({ bears: 0 }),\n}))\n```\n\n## Then bind your components, and that's it!\n\nYou can use the hook anywhere, without the need of providers.\nSelect your state and the consuming component\nwill re-render when that state changes.\n\n```jsx\nfunction BearCounter() {\n  const bears = useStore((state) => state.bears)\n  return <h1>{bears} around here...</h1>\n}\n\nfunction Controls() {\n  const increasePopulation = useStore((state) => state.increasePopulation)\n  return <button onClick={increasePopulation}>one up</button>\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/getting-started/introduction.md","loc":{"lines":{"from":29,"to":73}}}}],["18",{"pageContent":"---\ntitle: Auto Generating Selectors\nnav: 6\n---\n\nWe recommend using selectors when using either the properties or actions from the store. You can access values from the store like so:\n\n```typescript\nconst bears = useBearStore((state) => state.bears)\n```\n\nHowever, writing these could be tedious. If that is the case for you, you can auto-generate your selectors.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/auto-generating-selectors.md","loc":{"lines":{"from":1,"to":12}}}}],["19",{"pageContent":"create the following function: `createSelectors`\n\n```typescript\nimport { StoreApi, UseBoundStore } from 'zustand'\n\ntype WithSelectors<S> = S extends { getState: () => infer T }\n  ? S & { use: { [K in keyof T]: () => T[K] } }\n  : never\n\nconst createSelectors = <S extends UseBoundStore<StoreApi<object>>>(\n  _store: S\n) => {\n  let store = _store as WithSelectors<typeof _store>\n  store.use = {}\n  for (let k of Object.keys(store.getState())) {\n    ;(store.use as any)[k] = () => store((s) => s[k as keyof typeof s])\n  }\n\n  return store\n}\n```\n\nIf you have a store like this:\n\n```typescript\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n  increment: () => void\n}\n\nconst useBearStoreBase = create<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n  increment: () => set((state) => ({ bears: state.bears + 1 })),\n}))\n```\n\nApply that function to your store:\n\n```typescript\nconst useBearStore = createSelectors(useBearStoreBase)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/auto-generating-selectors.md","loc":{"lines":{"from":14,"to":55}}}}],["20",{"pageContent":"Apply that function to your store:\n\n```typescript\nconst useBearStore = createSelectors(useBearStoreBase)\n```\n\nNow the selectors are auto generated and you can access them directly:\n\n```typescript\n// get the property\nconst bears = useBearStore.use.bears()\n\n// get the action\nconst increase = useBearStore.use.increment()\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/auto-generating-selectors.md","loc":{"lines":{"from":55,"to":69}}}}],["21",{"pageContent":"Live Demo\n\nFor a working example of this, see the [Code Sandbox](https://codesandbox.io/s/zustand-auto-generate-selectors-forked-rl8v5e?file=/src/selectors.ts).\n\n## Third-party Libraries\n\n- [auto-zustand-selectors-hook](https://github.com/Albert-Gao/auto-zustand-selectors-hook)\n- [react-hooks-global-state](https://github.com/dai-shi/react-hooks-global-state)\n- [zustood](https://github.com/udecode/zustood)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/auto-generating-selectors.md","loc":{"lines":{"from":71,"to":79}}}}],["22",{"pageContent":"---\ntitle: Connect to state with URL hash\nnav: 12\n---","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/connect-to-state-with-url-hash.md","loc":{"lines":{"from":1,"to":4}}}}],["23",{"pageContent":"State is connected with URL hash\n\nIf you want to connect state of a store to URL hash, you can create your own hash storage.\n\n```ts\nimport { create } from 'zustand'\nimport { persist, StateStorage, createJSONStorage } from 'zustand/middleware'\n\nconst hashStorage: StateStorage = {\n  getItem: (key): string => {\n    const searchParams = new URLSearchParams(location.hash.slice(1))\n    const storedValue = searchParams.get(key) ?? ''\n    return storedValue\n  },\n  setItem: (key, newValue): void => {\n    const searchParams = new URLSearchParams(location.hash.slice(1))\n    searchParams.set(key, JSON.stringify(newValue))\n    location.hash = searchParams.toString()\n  },\n  removeItem: (key): void => {\n    const searchParams = new URLSearchParams(location.hash.slice(1))\n    searchParams.delete(key)\n    location.hash = searchParams.toString()\n  },\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/connect-to-state-with-url-hash.md","loc":{"lines":{"from":6,"to":30}}}}],["24",{"pageContent":"export const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      fishes: 0,\n      addAFish: () => set({ fishes: get().fishes + 1 }),\n    }),\n    {\n      name: 'food-storage', // unique name\n      storage: createJSONStorage(() => hashStorage),\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/connect-to-state-with-url-hash.md","loc":{"lines":{"from":32,"to":44}}}}],["25",{"pageContent":"CodeSandbox Demo\n\nhttps://codesandbox.io/s/zustand-state-with-url-hash-demo-pn20n5?file=/src/store/index.ts","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/connect-to-state-with-url-hash.md","loc":{"lines":{"from":46,"to":48}}}}],["26",{"pageContent":"---\ntitle: Calling actions outside a React event handler in pre React 18\nnav: 10\n---\n\nBecause React handles `setState` synchronously if it's called outside an event handler, updating the state outside an event handler will force react to update the components synchronously. Therefore, there is a risk of encountering the zombie-child effect.\nIn order to fix this, the action needs to be wrapped in `unstable_batchedUpdates` like so:\n\n```jsx\nimport { unstable_batchedUpdates } from 'react-dom' // or 'react-native'\n\nconst useFishStore = create((set) => ({\n  fishes: 0,\n  increaseFishes: () => set((prev) => ({ fishes: prev.fishes + 1 })),\n}))\n\nconst nonReactCallback = () => {\n  unstable_batchedUpdates(() => {\n    useFishStore.getState().increaseFishes()\n  })\n}\n```\n\nMore details: https://github.com/pmndrs/zustand/issues/302","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/event-handler-in-pre-react-18.md","loc":{"lines":{"from":1,"to":24}}}}],["27",{"pageContent":"---\ntitle: Flux inspired practice\nnav: 5\n---\n\nAlthough zustand is an unopinionated library, here are some patterns we recommend:\n\n- Create a single store;\n- Always use `set` to define a store;\n- Define your dispatch functions at the root level of the store to update one or more store slices.\n\n```js\nconst useBoundStore = create((set) => ({\n  storeSliceA: ...,\n  storeSliceB: ...,\n  storeSliceC: ...,\n  dispatchX: () => set(...),\n  dispatchY: () => set(...),\n}))\n```\n\nSee [Splitting the store into separate slices](./slices-pattern.md) for how to define a store with separate slices.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/flux-inspired-practice.md","loc":{"lines":{"from":1,"to":22}}}}],["28",{"pageContent":"Flux like patterns / \"dispatching\" actions\n\nIf you can't live without redux-like reducers, you can define a `dispatch` function on the root level of the store like so:\n\n```typescript\nconst types = { increase: 'INCREASE', decrease: 'DECREASE' }\n\nconst reducer = (state, { type, by = 1 }) => {\n  switch (type) {\n    case types.increase:\n      return { grumpiness: state.grumpiness + by }\n    case types.decrease:\n      return { grumpiness: state.grumpiness - by }\n  }\n}\n\nconst useGrumpyStore = create((set) => ({\n  grumpiness: 0,\n  dispatch: (args) => set((state) => reducer(state, args)),\n}))\n\nconst dispatch = useGrumpyStore((state) => state.dispatch)\ndispatch({ type: types.increase, by: 2 })\n```\n\nYou could also use our redux-middleware. It wires up your main reducer, sets initial state, and adds a dispatch function to the state itself and the vanilla api.\n\n```typescript\nimport { redux } from 'zustand/middleware'\n\nconst useReduxStore = create(redux(reducer, initialState))","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/flux-inspired-practice.md","loc":{"lines":{"from":24,"to":54}}}}],["29",{"pageContent":"Another way to update the store could be through functions wrapping the state functions. These could also handle side-effects of actions. For example, with HTTP-calls. To use Zustand in a none-reactive way, see [the readme](https://github.com/pmndrs/zustand#readingwriting-state-and-reacting-to-changes-outside-of-components).","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/flux-inspired-practice.md","loc":{"lines":{"from":57,"to":57}}}}],["30",{"pageContent":"---\ntitle: How to reset state\nnav: 13\n---\n\nThe following pattern can be used to reset the state to its initial value.\n\n```ts\nimport { create } from 'zustand'\n\n// define types for state values and actions separately\ntype State = {\n  salmon: number\n  tuna: number\n}\n\ntype Actions = {\n  addSalmon: (qty: number) => void\n  addTuna: (qty: number) => void\n  reset: () => void\n}\n\n// define the initial state\nconst initialState: State = {\n  salmon: 0,\n  tuna: 0,\n}\n\n// create store\nconst useSlice = create<State & Actions>()((set, get) => ({\n  ...initialState,\n\n  addSalmon: (qty: number) => {\n    set({ salmon: get().salmon + qty })\n  },\n\n  addTuna: (qty: number) => {\n    set({ tuna: get().tuna + qty })\n  },\n\n  reset: () => {\n    set(initialState)\n  },\n}))","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/how-to-reset-state.md","loc":{"lines":{"from":1,"to":44}}}}],["31",{"pageContent":"Resetting multiple stores at once\n\n```ts\nimport { create: _create, StateCreator } from 'zustand'\n\nconst resetters: (() => void)[] = []\n\nexport const create = (<T extends unknown>(f: StateCreator<T> | undefined) => {\n  if (f === undefined) return create\n  const store = _create(f)\n  const initialState = store.getState()\n  resetters.push(() => {\n    store.setState(initialState, true)\n  })\n  return store\n}) as typeof _create\n\nexport const resetAllStores = () => {\n  for (const resetter of resetters) {\n    resetter()\n  }\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/how-to-reset-state.md","loc":{"lines":{"from":47,"to":68}}}}],["32",{"pageContent":"Resetting bound store using Slices pattern\n\n```ts\nimport create, { StateCreator } from 'zustand'\n\nconst resetters: (() => void)[] = []\n\nconst initialBearState = { bears: 0 }\n\ninterface BearSlice {\n  bears: number\n  addBear: () => void\n  eatFish: () => void\n}\n\nconst createBearSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  BearSlice\n> = (set) => {\n  resetters.push(() => set(initialBearState))\n  return {\n    ...initialBearState,\n    addBear: () => set((state) => ({ bears: state.bears + 1 })),\n    eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),\n  }\n}\n\nconst initialStateFish = { fishes: 0 }\n\ninterface FishSlice {\n  fishes: number\n  addFish: () => void\n}\n\nconst createFishSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  FishSlice\n> = (set) => {\n  resetters.push(() => set(initialStateFish))\n  return {\n    ...initialStateFish,\n    addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n  }\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/how-to-reset-state.md","loc":{"lines":{"from":71,"to":118}}}}],["33",{"pageContent":"const useBoundStore = create<BearSlice & FishSlice>()((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n}))\n\nexport const resetAllSlices = () => resetters.forEach((resetter) => resetter())\n\nexport default useBoundStore\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/how-to-reset-state.md","loc":{"lines":{"from":120,"to":128}}}}],["34",{"pageContent":"CodeSandbox Demo\n\n- Basic: https://codesandbox.io/s/zustand-how-to-reset-state-basic-demo-rrqyon\n- Advanced: https://codesandbox.io/s/zustand-how-to-reset-state-advanced-demo-gtu0qe\n- Immer: https://codesandbox.io/s/how-to-reset-state-advance-immer-demo-nyet3f","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/how-to-reset-state.md","loc":{"lines":{"from":130,"to":134}}}}],["35",{"pageContent":"---\ntitle: Immutable state and merging\nnav: 4\n---\n\nLike with React's `useState`, we need to update state immutably.\n\nHere's a typical example:\n\n```jsx\nimport { create } from 'zustand'\n\nconst useCountStore = create((set) => ({\n  count: 0,\n  inc: () => set((state) => ({ count: state.count + 1 })),\n}))\n```\n\nThe `set` function is to update state in the store.\nBecause the state is immutable, it should have been like this:\n\n```js\nset((state) => ({ ...state, count: state.count + 1 }))\n```\n\nHowever, as this is a common pattern, `set` actually merges state, and\nwe can skip the `...state` part:\n\n```js\nset((state) => ({ count: state.count + 1 }))\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/immutable-state-and-merging.md","loc":{"lines":{"from":1,"to":31}}}}],["36",{"pageContent":"Nested objects\n\nThe `set` function merges state at only one level.\nIf you have a nested object, you need to merge them explicitly. You will use the spread operator pattern like so:\n\n```jsx\nimport { create } from 'zustand'\n\nconst useCountStore = create((set) => ({\n  nested: { count: 0 },\n  inc: () =>\n    set((state) => ({\n      nested: { ...state.nested, count: state.nested.count + 1 },\n    })),\n}))\n```\n\nFor complex use cases, consider using some libraries that help with immutable updates.\nYou can refer to [Updating nested state object values](./updating-state.md#deeply-nested-object).\n\n## Replace flag\n\nTo disable the merging behavior, you can specify a `replace` boolean value for `set` like so:\n\n```js\nset((state) => newState, true)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/immutable-state-and-merging.md","loc":{"lines":{"from":33,"to":59}}}}],["37",{"pageContent":"---\ntitle: Initialize state with props\nnav: 14\n---\n\nIn cases where [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) is needed, such as when a store should be initialized with props from a component, the recommended approach is to use a vanilla store with React.context.\n\n## Store creator with `createStore`\n\n```ts\nimport { createStore } from 'zustand'\n\ninterface BearProps {\n  bears: number\n}\n\ninterface BearState extends BearProps {\n  addBear: () => void\n}\n\ntype BearStore = ReturnType<typeof createBearStore>\n\nconst createBearStore = (initProps?: Partial<BearProps>) => {\n  const DEFAULT_PROPS: BearProps = {\n    bears: 0,\n  }\n  return createStore<BearState>()((set) => ({\n    ...DEFAULT_PROPS,\n    ...initProps,\n    addBear: () => set((state) => ({ bears: ++state.bears })),\n  }))\n}\n```\n\n## Creating a context with `React.createContext`\n\n```ts\nimport { createContext } from 'react'\n\nexport const BearContext = createContext<BearStore | null>(null)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/initialize-state-with-props.md","loc":{"lines":{"from":1,"to":41}}}}],["38",{"pageContent":"Creating a context with `React.createContext`\n\n```ts\nimport { createContext } from 'react'\n\nexport const BearContext = createContext<BearStore | null>(null)\n```\n\n## Basic component usage\n\n```tsx\n// Provider implementation\nimport { useRef } from 'react'\n\nfunction App() {\n  const store = useRef(createBearStore()).current\n  return (\n    <BearContext.Provider value={store}>\n      <BasicConsumer />\n    </BearContext.Provider>\n  )\n}\n```\n\n```tsx\n// Consumer component\nimport { useContext } from 'react'\nimport { useStore } from 'zustand'\n\nfunction BasicConsumer() {\n  const store = useContext(BearContext)\n  if (!store) throw new Error('Missing BearContext.Provider in the tree')\n  const bears = useStore(store, (s) => s.bears)\n  const addBear = useStore(store, (s) => s.addBear)\n  return (\n    <>\n      <div>{bears} Bears.</div>\n      <button onClick={addBear}>Add bear</button>\n    </>\n  )\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/initialize-state-with-props.md","loc":{"lines":{"from":41,"to":82}}}}],["39",{"pageContent":"Common patterns\n\n### Wrapping the context provider\n\n```tsx\n// Provider wrapper\nimport { useRef } from 'react'\n\ntype BearProviderProps = React.PropsWithChildren<BearProps>\n\nfunction BearProvider({ children, ...props }: BearProviderProps) {\n  const storeRef = useRef<BearStore>()\n  if (!storeRef.current) {\n    storeRef.current = createBearStore(props)\n  }\n  return (\n    <BearContext.Provider value={storeRef.current}>\n      {children}\n    </BearContext.Provider>\n  )\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/initialize-state-with-props.md","loc":{"lines":{"from":84,"to":105}}}}],["40",{"pageContent":"Extracting context logic into a custom hook\n\n```tsx\n// Mimic the hook returned by `create`\nimport { useContext } from 'react'\nimport { useStore } from 'zustand'\n\nfunction useBearContext<T>(\n  selector: (state: BearState) => T,\n  equalityFn?: (left: T, right: T) => boolean\n): T {\n  const store = useContext(BearContext)\n  if (!store) throw new Error('Missing BearContext.Provider in the tree')\n  return useStore(store, selector, equalityFn)\n}\n```\n\n```tsx\n// Consumer usage of the custom hook\nfunction CommonConsumer() {\n  const bears = useBearContext((s) => s.bears)\n  const addBear = useBearContext((s) => s.addBear)\n  return (\n    <>\n      <div>{bears} Bears.</div>\n      <button onClick={addBear}>Add bear</button>\n    </>\n  )\n}\n```\n\n### Complete example\n\n```tsx\n// Provider wrapper & custom hook consumer\nfunction App2() {\n  return (\n    <BearProvider bears={2}>\n      <HookConsumer />\n    </BearProvider>\n  )\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/initialize-state-with-props.md","loc":{"lines":{"from":107,"to":149}}}}],["41",{"pageContent":"---\ntitle: Map and Set Usage\nnav: 11\n---\n\nYou need to wrap Maps and Sets inside an object. When you want its update to be reflected (e.g. in React),\nyou do it by calling `setState` on it:\n\n**You can view a codesandbox here: https://codesandbox.io/s/late-https-bxz9qy**\n\n```js\nimport { create } from 'zustand'\n\nconst useFooBar = create(() => ({ foo: new Map(), bar: new Set() }))\n\nfunction doSomething() {\n  // doing something...\n\n  // If you want to update some React component that uses `useFooBar`, you have to call setState\n  // to let React know that an update happened.\n  // Following React's best practices, you should create a new Map/Set when updating them:\n  useFooBar.setState((prev) => ({\n    foo: new Map(prev.foo).set('newKey', 'newValue'),\n    bar: new Set(prev.bar).add('newKey'),\n  }))\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/maps-and-sets-usage.md","loc":{"lines":{"from":1,"to":27}}}}],["42",{"pageContent":"---\ntitle: Practice with no store actions\nnav: 7\n---\n\nThe recommended usage is to colocate actions and states within the store (let your actions be located together with your state).\n\nFor example:\n\n```js\nexport const useBoundStore = create((set) => ({\n  count: 0,\n  text: 'hello',\n  inc: () => set((state) => ({ count: state.count + 1 })),\n  setText: (text) => set({ text }),\n}))\n```\n\nThis creates a self-contained store with data and actions together.\n\n---\n\nAn alternative approach is to define actions at module level, external to the store.\n\n```js\nexport const useBoundStore = create(() => ({\n  count: 0,\n  text: 'hello',\n}))\n\nexport const inc = () =>\n  useBoundStore.setState((state) => ({ count: state.count + 1 }))\n\nexport const setText = (text) => useBoundStore.setState({ text })\n```\n\nThis has a few advantages:\n\n- It doesn't require a hook to call an action;\n- It facilitates code splitting.\n\nWhile this pattern doesn't offer any downsides, some may prefer colocating due to its encapsulated nature.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/practice-with-no-store-actions.md","loc":{"lines":{"from":1,"to":42}}}}],["43",{"pageContent":"---\ntitle: Slices Pattern\nnav: 15\n---","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/slices-pattern.md","loc":{"lines":{"from":1,"to":4}}}}],["44",{"pageContent":"Slicing the store into smaller stores\n\nYour store can become bigger and bigger and tougher to maintain as you add more features.\n\nYou can divide your main store into smaller individual stores to achieve modularity. This is simple to accomplish in Zustand!\n\nThe first individual store:\n\n```js\nexport const createFishSlice = (set) => ({\n  fishes: 0,\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n})\n```\n\nAnother individual store:\n\n```js\nexport const createBearSlice = (set) => ({\n  bears: 0,\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\n  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),\n})\n```\n\nYou can now combine both the stores into **one bounded store**:\n\n```js\nimport { create } from 'zustand'\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\n\nexport const useBoundStore = create((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n}))\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/slices-pattern.md","loc":{"lines":{"from":6,"to":42}}}}],["45",{"pageContent":"Usage in a React component\n\n```jsx\nimport { useBoundStore } from './stores/useBoundStore'\n\nfunction App() {\n  const bears = useBoundStore((state) => state.bears)\n  const fishes = useBoundStore((state) => state.fishes)\n  const addBear = useBoundStore((state) => state.addBear)\n  return (\n    <div>\n      <h2>Number of bears: {bears}</h2>\n      <h2>Number of fishes: {fishes}</h2>\n      <button onClick={() => addBear()}>Add a bear</button>\n    </div>\n  )\n}\n\nexport default App\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/slices-pattern.md","loc":{"lines":{"from":44,"to":63}}}}],["46",{"pageContent":"Updating multiple stores\n\nYou can update multiple stores, at the same time, in a single function.\n\n```js\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\n\nexport const createBearFishSlice = (set) => ({\n  addBearAndFish: () => {\n    createBearSlice(set).addBear()\n    createFishSlice(set).addFish()\n  },\n})\n```\n\nCombining all the stores together is the same as before.\n\n```js\nimport { create } from 'zustand'\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\nimport { createBearFishSlice } from './createBearFishSlice'\n\nexport const useBoundStore = create((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n  ...createBearFishSlice(...a),\n}))\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/slices-pattern.md","loc":{"lines":{"from":65,"to":94}}}}],["47",{"pageContent":"Adding middlewares\n\nAdding middlewares to a combined store is the same as with other normal stores.\n\nAdding `persist` middleware to our `useBoundStore`:\n\n```js\nimport { create } from 'zustand'\nimport { createBearSlice } from './bearSlice'\nimport { createFishSlice } from './fishSlice'\nimport { persist } from 'zustand/middleware'\n\nexport const useBoundStore = create(\n  persist(\n    (...a) => ({\n      ...createBearSlice(...a),\n      ...createFishSlice(...a),\n    }),\n    { name: 'bound-store' }\n  )\n)\n```\n\n## Usage with TypeScript\n\nA detailed guide on how to use the slice pattern in Zustand with TypeScript can be found [here](./typescript.md#slices-pattern).","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/slices-pattern.md","loc":{"lines":{"from":96,"to":121}}}}],["48",{"pageContent":"---\ntitle: Testing\ndescription: How to test your new store\nnav: 9\n---","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":1,"to":5}}}}],["49",{"pageContent":"Resetting state between tests in **react-dom**\n\nWhen running tests, the stores are not automatically reset before each test run.\n\nThus, there can be cases where the state of one test can affect another. To make sure all tests run\nwith a pristine store state, you can mock `zustand` during testing and use the following code to\ncreate your store:\n\n```js\nimport { create as actualCreate } from 'zustand'\n// const { create: actualCreate } = jest.requireActual('zustand') // if using jest\nimport { act } from 'react-dom/test-utils'\n\n// a variable to hold reset functions for all stores declared in the app\nconst storeResetFns = new Set()\n\n// when creating a store, we get its initial state, create a reset function and add it in the set\nexport const create = (createState) => {\n  const store = actualCreate(createState)\n  const initialState = store.getState()\n  storeResetFns.add(() => store.setState(initialState, true))\n  return store\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":7,"to":29}}}}],["50",{"pageContent":"// Reset all stores after each test run\nbeforeEach(() => {\n  act(() => storeResetFns.forEach((resetFn) => resetFn()))\n})","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":31,"to":34}}}}],["51",{"pageContent":"The way you mock a dependency depends on your test runner/library.\n\nIn [jest](https://jestjs.io/), you can create a `__mocks__/zustand.js` and place the code in that\nfile. If your app is using `zustand/vanilla` instead of `zustand`, then you'll have to place the\nabove code in `__mocks__/zustand/vanilla.js`.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":37,"to":41}}}}],["52",{"pageContent":"TypeScript usage\n\nIf you are using zustand, as documented in [TypeScript Guide](./typescript.md), use the following\ncode:\n\n```ts\nimport { create as actualCreate, StateCreator } from 'zustand'\n// if using Jest:\n// import { StateCreator } from 'zustand';\n// const { create: actualCreate } = jest.requireActual<typeof import('zustand')>('zustand');\nimport { act } from 'react-dom/test-utils'\n\n// a variable to hold reset functions for all stores declared in the app\nconst storeResetFns = new Set<() => void>()\n\n// when creating a store, we get its initial state, create a reset function and add it in the set\nconst create =\n  () =>\n  <S>(createState: StateCreator<S>) => {\n    const store = actualCreate(createState)\n    const initialState = store.getState()\n    storeResetFns.add(() => store.setState(initialState, true))\n    return store\n  }\n\n// Reset all stores after each test run\nbeforeEach(() => {\n  act(() => storeResetFns.forEach((resetFn) => resetFn()))\n})\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":43,"to":72}}}}],["53",{"pageContent":"Resetting state between tests in **react-native** and **jest**\n\nYou should use the following code in the `__mocks__/zustand.js` file (the `__mocks__` directory\nshould be adjacent to node_modules, placed in the same folder as node_modules, unless you\nconfigured roots to point to a folder other than the project root [jest docs: mocking node modules](https://jestjs.io/docs/manual-mocks#mocking-node-modules)):\n\n```js\nimport { act } from '@testing-library/react-native'\nconst { create: actualCreate } = jest.requireActual('zustand')\n\n// a variable to hold reset functions for all stores declared in the app\nconst storeResetFns = new Set()\n\n// when creating a store, we get its initial state, create a reset function and add it in the set\nexport const create = (createState) => {\n  const store = actualCreate(createState)\n  const initialState = store.getState()\n  storeResetFns.add(() => store.setState(initialState, true))\n  return store\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":74,"to":93}}}}],["54",{"pageContent":"// Reset all stores after each test run\nbeforeEach(() => {\n  act(() => storeResetFns.forEach((resetFn) => resetFn()))\n})","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":93,"to":96}}}}],["55",{"pageContent":"If the `jest.config.js` has `automock: false`, then you need to do the following in `jest.setup.js`:\n\n```js\njest.mock('zustand')\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/testing.md","loc":{"lines":{"from":163,"to":167}}}}],["56",{"pageContent":"---\ntitle: TypeScript Guide\nnav: 8\n---","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":1,"to":4}}}}],["57",{"pageContent":"Basic usage\n\nThe difference when using TypeScript is that instead of writing `create(...)`, you have to write `create<T>()(...)` (notice the extra parenthesis `()` too along with the type parameter) where `T` is the type of the state to annotate it. For example:\n\n```ts\nimport { create } from 'zustand'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n```\n\n<details>\n  <summary>Why can't we simply infer the type from the initial state?</summary>\n\n  <br/>\n\n**TLDR**: Because state generic `T` is invariant.\n\nConsider this minimal version `create`:\n\n```ts\ndeclare const create: <T>(f: (get: () => T) => T) => T\n\nconst x = create((get) => ({\n  foo: 0,\n  bar: () => get(),\n}))\n// `x` is inferred as `unknown` instead of\n// interface X {\n//   foo: number,\n//   bar: () => X\n// }","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":6,"to":44}}}}],["58",{"pageContent":"Here, if you look at the type of `f` in `create`, i.e. `(get: () => T) => T`, it \"gives\" `T` via return (making it covariant), but it also \"takes\" `T` via `get` (making it contravariant). \"So where does `T` come from?\" TypeScript wonders. It's like that chicken or egg problem. At the end TypeScript, gives up and infers `T` as `unknown`.\n\nSo, as long as the generic to be inferred is invariant (i.e. both covariant and contravariant), TypeScript will be unable to infer it. Another simple example would be this:\n\n```ts\nconst createFoo = {} as <T>(f: (t: T) => T) => T\nconst x = createFoo((_) => 'hello')","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":47,"to":53}}}}],["59",{"pageContent":"Here again, `x` is `unknown` instead of `string`.\n\n  <details>\n    <summary>More about the inference (just for the people curious and interested in TypeScript)</summary>\n\nIn some sense this inference failure is not a problem because a value of type `<T>(f: (t: T) => T) => T` cannot be written. That is to say you can't write the real runtime implementation of `createFoo`. Let's try it:\n\n```js\nconst createFoo = (f) => f(/* ? */)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":56,"to":64}}}}],["60",{"pageContent":"`createFoo` needs to return the return value of `f`. And to do that we first have to call `f`. And to call it we have to pass a value of type `T`. And to pass a value of type `T` we first have to produce it. But how can we produce a value of type `T` when we don't even know what `T` is? The only way to produce a value of type `T` is to call `f`, but then to call `f` itself we need a value of type `T`. So you see it's impossible to actually write `createFoo`.\n\nSo what we're saying is, the inference failure in case of `createFoo` is not really a problem because it's impossible to implement `createFoo`. But what about the inference failure in case of `create`? That also is not really a problem because it's impossible to implement `create` too. Wait a minute, if it's impossible to implement `create` then how does Zustand implement it? The answer is, it doesn't.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":67,"to":69}}}}],["61",{"pageContent":"Zustand lies that it implemented `create`'s type, it implemented only the most part of it. Here's a simple proof by showing unsoundness. Consider the following code:\n\n```ts\nimport { create } from 'zustand'\n\nconst useBoundStore = create<{ foo: number }>()((_, get) => ({\n  foo: get().foo,\n}))","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":71,"to":78}}}}],["62",{"pageContent":"This code compiles. But if we run it, we'll get an exception: \"Uncaught TypeError: Cannot read properties of undefined (reading 'foo')\". This is because `get` would return `undefined` before the initial state is created (hence you shouldn't call `get` when creating the initial state). The types promise that `get` will never return `undefined` but it does initially, which means Zustand failed to implement it.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":81,"to":81}}}}],["63",{"pageContent":"And of course Zustand failed because it's impossible to implement `create` the way types promise (in the same way it's impossible to implement `createFoo`). In other words we don't have a type to express the actual `create` we have implemented. We can't type `get` as `() => T | undefined` because it would cause inconveince and it still won't be correct as `get` is indeed `() => T` eventually, just if called synchronously it would be `() => undefined`. What we need is some kind of TypeScript feature that allows us to type `get` as `(() => T) & WhenSync<() => undefined>`, which of course is extremly far-fetched.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":83,"to":83}}}}],["64",{"pageContent":"So we have two problems: lack of inference and unsoundness. Lack of inference can be solved if TypeScript can improves its inference for invariants. And unsoundness can be solved if TypeScript introduces something like `WhenSync`. To work around lack of inference we manually annotate the state type. And we can't work around unsoundness, but it's not a big deal because it's not much, calling `get` synchronously anyway doesn't make sense.\n\n</details>\n\n</details>\n\n<details>\n  <summary>Why that currying `()(...)`?</summary>\n\n  <br/>\n\n**TLDR**: It is a workaround for [microsoft/TypeScript#10571](https://github.com/microsoft/TypeScript/issues/10571).\n\nImagine you have a scenario like this:\n\n```ts\ndeclare const withError: <T, E>(\n  p: Promise<T>\n) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>\ndeclare const doSomething: () => Promise<string>\n\nconst main = async () => {\n  let [error, value] = await withError(doSomething())\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":85,"to":108}}}}],["65",{"pageContent":"Here, `T` is inferred to be a `string` and `E` is inferred to be `unknown`. You might want to annotate `E` as `Foo`, because you are certain of the shape of error `doSomething()` would throw. However, you can't do that. You can either pass all generics or none. Along with annotating `E` as `Foo`, you will also have to annotate `T` as `string` even though it gets inferred anyway. The solution is to make a curried version of `withError` that does nothing at runtime. Its purpose is to just allow you annotate `E`.\n\n```ts\ndeclare const withError: {\n  <E>(): <T>(\n    p: Promise<T>\n  ) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>\n  <T, E>(p: Promise<T>): Promise<\n    [error: undefined, value: T] | [error: E, value: undefined]\n  >\n}\ndeclare const doSomething: () => Promise<string>\ninterface Foo {\n  bar: string\n}\n\nconst main = async () => {\n  let [error, value] = await withError<Foo>()(doSomething())\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":111,"to":129}}}}],["66",{"pageContent":"This way, `T` gets inferred and you get to annotate `E`. Zustand has the same use case when we want to annotate the state (the first type parameter) but allow other parameters to get inferred.\n\n</details>\n\nAlternatively, you can also use `combine`, which infers the state so that you do not need to type it.\n\n```ts\nimport { create } from 'zustand'\nimport { combine } from 'zustand/middleware'\n\nconst useBearStore = create(\n  combine({ bears: 0 }, (set) => ({\n    increase: (by: number) => set((state) => ({ bears: state.bears + by })),\n  }))\n)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":132,"to":146}}}}],["67",{"pageContent":"<details>\n  <summary>Be a little careful</summary>\n\n  <br/>\n\nWe achieve the inference by lying a little in the types of `set`, `get`, and `store` that you receive as parameters. The lie is that they're typed as if the state is the first parameter, when in fact the state is the shallow-merge (`{ ...a, ...b }`) of both first parameter and the second parameter's return. For example, `get` from the second parameter has type `() => { bears: number }` and that is a lie as it should be `() => { bears: number, increase: (by: number) => void }`. And `useBearStore` still has the correct type; for example, `useBearStore.getState` is typed as `() => { bears: number, increase: (by: number) => void }`.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":149,"to":154}}}}],["68",{"pageContent":"It isn't really a lie because `{ bears: number }` is still a subtype of `{ bears: number, increase: (by: number) => void }`. Therefore, there will be no problem in most cases. You should just be careful while using replace. For example, `set({ bears: 0 }, true)` would compile but will be unsound as it will delete the `increase` function. Another instance where you should be careful is if you use `Object.keys`. `Object.keys(get())` will return `[\"bears\", \"increase\"]` and not `[\"bears\"]`. The return type of `get` can make you fall for these mistakes.\n\n`combine` trades off a little type-safety for the convenience of not having to write a type for state. Hence, you should use `combine` accordingly. It is fine in most cases and you can use it conveniently.\n\n</details>","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":156,"to":160}}}}],["69",{"pageContent":"</details>\n\nNote that we don't use the curried version when using `combine` because `combine` \"creates\" the state. When using a middleware that creates the state, it isn't necessary to use the curried version because the state now can be inferred. Another middleware that creates state is `redux`. So when using `combine`, `redux`, or any other custom middleware that creates the state, we don't recommend using the curried version.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":160,"to":162}}}}],["70",{"pageContent":"Using middlewares\n\nYou do not have to do anything special to use middlewares in TypeScript.\n\n```ts\nimport { create } from 'zustand'\nimport { devtools, persist } from 'zustand/middleware'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()(\n  devtools(\n    persist((set) => ({\n      bears: 0,\n      increase: (by) => set((state) => ({ bears: state.bears + by })),\n    }))\n  )\n)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":164,"to":184}}}}],["71",{"pageContent":"Just make sure you are using them immediately inside `create` so as to make the contextual inference work. Doing something even remotely fancy like the following `myMiddlewares` would require more advanced types.\n\n```ts\nimport { create } from 'zustand'\nimport { devtools, persist } from 'zustand/middleware'\n\nconst myMiddlewares = (f) => devtools(persist(f))\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<BearState>()(\n  myMiddlewares((set) => ({\n    bears: 0,\n    increase: (by) => set((state) => ({ bears: state.bears + by })),\n  }))\n)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":187,"to":205}}}}],["72",{"pageContent":"Also, we recommend using `devtools` middleware as last as possible. For example, when you use it with `immer` as a middleware, it should be `immer(devtools(...))` and not `devtools(immer(...))`. This is because`devtools` mutates the `setState` and adds a type parameter on it, which could get lost if other middlewares (like `immer`) also mutate `setState` before `devtools`. Hence using `devtools` at the end makes sure that no middlewares mutate `setState` before it.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":208,"to":208}}}}],["73",{"pageContent":"Authoring middlewares and advanced usage\n\nImagine you had to write this hypothetical middleware.\n\n```ts\nimport { create } from 'zustand'\n\nconst foo = (f, bar) => (set, get, store) => {\n  store.foo = bar\n  return f(set, get, store)\n}\n\nconst useBearStore = create(foo(() => ({ bears: 0 }), 'hello'))\nconsole.log(useBearStore.foo.toUpperCase())","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":210,"to":223}}}}],["74",{"pageContent":"Zustand middlewares can mutate the store. But how could we possibly encode the mutation on the type-level? That is to say how could do we type `foo` so that this code compiles?\n\nFor a usual statically typed language, this is impossible. But thanks to TypeScript, Zustand has something called a \"higher-kinded mutator\" that makes this possible. If you are dealing with complex type problems, like typing a middleware or using the `StateCreator` type, you will have to understand this implementation detail. For this, you can [check out #710](https://github.com/pmndrs/zustand/issues/710).\n\nIf you are eager to know what the answer is to this particular problem then you can [see it here](#middleware-that-changes-the-store-type).","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":226,"to":230}}}}],["75",{"pageContent":"Common recipes","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":232,"to":232}}}}],["76",{"pageContent":"Middleware that doesn't change the store type\n\n```ts\nimport { create, State, StateCreator, StoreMutatorIdentifier } from 'zustand'\n\ntype Logger = <\n  T extends State,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = []\n>(\n  f: StateCreator<T, Mps, Mcs>,\n  name?: string\n) => StateCreator<T, Mps, Mcs>\n\ntype LoggerImpl = <T extends State>(\n  f: StateCreator<T, [], []>,\n  name?: string\n) => StateCreator<T, [], []>\n\nconst loggerImpl: LoggerImpl = (f, name) => (set, get, store) => {\n  type T = ReturnType<typeof f>\n  const loggedSet: typeof set = (...a) => {\n    set(...a)\n    console.log(...(name ? [`${name}:`] : []), get())\n  }\n  store.setState = loggedSet\n\n  return f(loggedSet, get, store)\n}\n\nexport const logger = loggerImpl as unknown as Logger\n\n// ---\n\nconst useBearStore = create<BearState>()(\n  logger(\n    (set) => ({\n      bears: 0,\n      increase: (by) => set((state) => ({ bears: state.bears + by })),\n    }),\n    'bear-store'\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":234,"to":277}}}}],["77",{"pageContent":"Middleware that changes the store type\n\n```ts\nimport {\n  create,\n  State,\n  StateCreator,\n  StoreMutatorIdentifier,\n  Mutate,\n  StoreApi,\n} from 'zustand'\n\ntype Foo = <\n  T extends State,\n  A,\n  Mps extends [StoreMutatorIdentifier, unknown][] = [],\n  Mcs extends [StoreMutatorIdentifier, unknown][] = []\n>(\n  f: StateCreator<T, [...Mps, ['foo', A]], Mcs>,\n  bar: A\n) => StateCreator<T, Mps, [['foo', A], ...Mcs]>\n\ndeclare module 'zustand' {\n  interface StoreMutators<S, A> {\n    foo: Write<Cast<S, object>, { foo: A }>\n  }\n}\n\ntype FooImpl = <T extends State, A>(\n  f: StateCreator<T, [], []>,\n  bar: A\n) => StateCreator<T, [], []>\n\nconst fooImpl: FooImpl = (f, bar) => (set, get, _store) => {\n  type T = ReturnType<typeof f>\n  type A = typeof bar\n\n  const store = _store as Mutate<StoreApi<T>, [['foo', A]]>\n  store.foo = bar\n  return f(set, get, _store)\n}\n\nexport const foo = fooImpl as unknown as Foo\n\ntype Write<T extends object, U extends object> = Omit<T, keyof U> & U\n\ntype Cast<T, U> = T extends U ? T : U","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":279,"to":325}}}}],["78",{"pageContent":"export const foo = fooImpl as unknown as Foo\n\ntype Write<T extends object, U extends object> = Omit<T, keyof U> & U\n\ntype Cast<T, U> = T extends U ? T : U\n\n// ---\n\nconst useBearStore = create(foo(() => ({ bears: 0 }), 'hello'))\nconsole.log(useBearStore.foo.toUpperCase())\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":325,"to":335}}}}],["79",{"pageContent":"`create` without curried workaround\n\nThe recommended way to use `create` is using the curried workaround like so: `create<T>()(...)`. This is because it enables you to infer the store type. But if for some reason you do not want to use the workaround, you can pass the type parameters like the following. Note that in some cases, this acts as an assertion instead of annotation, so we don't recommend it.\n\n```ts\nimport { create } from \"zustand\"\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst useBearStore = create<\n  BearState,\n  [\n    ['zustand/persist', BearState],\n    ['zustand/devtools', never]\n  ]\n>(devtools(persist((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n})))\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":337,"to":359}}}}],["80",{"pageContent":"Slices pattern\n\n```ts\nimport { create, StateCreator } from 'zustand'\n\ninterface BearSlice {\n  bears: number\n  addBear: () => void\n  eatFish: () => void\n}\nconst createBearSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  BearSlice\n> = (set) => ({\n  bears: 0,\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\n  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),\n})\n\ninterface FishSlice {\n  fishes: number\n  addFish: () => void\n}\nconst createFishSlice: StateCreator<\n  BearSlice & FishSlice,\n  [],\n  [],\n  FishSlice\n> = (set) => ({\n  fishes: 0,\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\n})\n\nconst useBoundStore = create<BearSlice & FishSlice>()((...a) => ({\n  ...createBearSlice(...a),\n  ...createFishSlice(...a),\n}))","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":361,"to":399}}}}],["81",{"pageContent":"A detailed explanation on the slices pattern can be found [here](./slices-pattern.md).\n\nIf you have some middlewares then replace `StateCreator<MyState, [], [], MySlice>` with `StateCreator<MyState, Mutators, [], MySlice>`. For example, if you are using `devtools` then it will be `StateCreator<MyState, [[\"zustand/devtools\", never]], [], MySlice>`. See the [\"Middlewares and their mutators reference\"](#middlewares-and-their-mutators-reference) section for a list of all mutators.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":402,"to":404}}}}],["82",{"pageContent":"Bounded `useStore` hook for vanilla stores\n\n```ts\nimport { useStore } from 'zustand'\nimport { createStore } from 'zustand/vanilla'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst bearStore = createStore<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n\nfunction useBearStore(): BearState\nfunction useBearStore<T>(\n  selector: (state: BearState) => T,\n  equals?: (a: T, b: T) => boolean\n): T\nfunction useBearStore<T>(\n  selector?: (state: BearState) => T,\n  equals?: (a: T, b: T) => boolean\n) {\n  return useStore(bearStore, selector!, equals)\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":406,"to":432}}}}],["83",{"pageContent":"You can also make an abstract `createBoundedUseStore` if you create bounded `useStore`s often and want to DRY things up...\n\n```ts\nimport { useStore, StoreApi } from 'zustand'\nimport { createStore } from 'zustand/vanilla'\n\ninterface BearState {\n  bears: number\n  increase: (by: number) => void\n}\n\nconst bearStore = createStore<BearState>()((set) => ({\n  bears: 0,\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\n}))\n\nconst createBoundedUseStore = ((store) => (selector, equals) =>\n  useStore(store, selector as any, equals)) as <S extends StoreApi<unknown>>(\n  store: S\n) => {\n  (): ExtractState<S>\n  <T>(\n    selector?: (state: ExtractState<S>) => T,\n    equals?: (a: T, b: T) => boolean\n  ): T\n}\n\ntype ExtractState<S> = S extends { getState: () => infer X } ? X : never\n\nconst useBearStore = createBoundedUseStore(bearStore)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":435,"to":465}}}}],["84",{"pageContent":"Middlewares and their mutators reference\n\n- `devtools` — `[\"zustand/devtools\", never]`\n- `persist` — `[\"zustand/persist\", YourPersistedState]`<br/>\n  `YourPersistedState` is the type of state you are going to persist, ie the return type of `options.partialize`, if you're not passing `partialize` options the `YourPersistedState` becomes `Partial<YourState>`. Also [sometimes](https://github.com/pmndrs/zustand/issues/980#issuecomment-1162289836) passing actual `PersistedState` won't work. In those cases, try passing `unknown`.\n- `immer` — `[\"zustand/immer\", never]`\n- `subscribeWithSelector` — `[\"zustand/subscribeWithSelector\", never]`\n- `redux` — `[\"zustand/redux\", YourAction]`\n- `combine` — no mutator as `combine` does not mutate the store","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/typescript.md","loc":{"lines":{"from":467,"to":475}}}}],["85",{"pageContent":"---\ntitle: Updating state\nnav: 3\n---","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/updating-state.md","loc":{"lines":{"from":1,"to":4}}}}],["86",{"pageContent":"Flat updates\n\nUpdating state with Zustand is simple! Call the provided `set` function with\nthe new state, and it will be shallowly merged with the existing state in the\nstore. **Note** See next section for nested state.\n\n```tsx\ntype State = {\n  firstName: string\n  lastName: string\n}\n\ntype Action = {\n  updateFirstName: (firstName: State['firstName']) => void\n  updateLastName: (lastName: State['lastName']) => void\n}\n\n// Create your store, which includes both state and (optionally) actions\nconst useStore = create<State & Action>((set) => ({\n  firstName: '',\n  lastName: '',\n  updateFirstName: (firstName) => set(() => ({ firstName: firstName })),\n  updateLastName: (lastName) => set(() => ({ lastName: lastName })),\n}))\n\n// In consuming app\nfunction App() {\n  // \"select\" the needed state and actions, in this case, the firstName value\n  // and the action updateFirstName\n  const [firstName, updateFirstName] = useStore(\n    (state) => [state.firstName, state.updateFirstName],\n    shallow\n  )","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/updating-state.md","loc":{"lines":{"from":6,"to":38}}}}],["87",{"pageContent":"return (\n    <main>\n      <label>\n        First name\n        <input\n          // Update the \"firstName\" state\n          onChange={(e) => updateFirstName(e.currentTarget.value)}\n          value={firstName}\n        />\n      </label>\n\n      <p>\n        Hello, <strong>{firstName}!</strong>\n      </p>\n    </main>\n  )\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/updating-state.md","loc":{"lines":{"from":40,"to":57}}}}],["88",{"pageContent":"Deeply nested object\n\nIf you have a deep state object like this:\n\n```ts\ntype State = {\n  deep: {\n    nested: {\n      obj: { count: number }\n    }\n  }\n}\n```\n\nUpdating nested state requires some effort to ensure the process is completed\nimmutably.\n\n### Normal approach\n\nSimilar to React or Redux, the normal approach is to copy each level of the\nstate object. This is done with the spread operator `...`, and by manually\nmerging that in with the new state values. Like so:\n\n```ts\n  normalInc: () =>\n    set((state) => ({\n      deep: {\n        ...state.deep,\n        nested: {\n          ...state.deep.nested,\n          obj: {\n            ...state.deep.nested.obj,\n            count: state.deep.nested.obj.count + 1\n          }\n        }\n      }\n    })),\n```\n\nThis is very long! Let's explore some alternatives that will make your life\neasier.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/updating-state.md","loc":{"lines":{"from":59,"to":99}}}}],["89",{"pageContent":"With Immer\n\nMany people use [Immer](https://github.com/immerjs/immer) to update nested\nvalues. Immer can be used anytime you need to update nested state such as in\nReact, Redux and of course, Zustand!\n\nYou can use Immer to shorten your state updates for deeply nested object. Let's\ntake a look at an example:\n\n```ts\n  immerInc: () =>\n    set(produce((state: State) => { ++state.deep.nested.obj.count })),\n```\n\nWhat a reduction! Please take note of the [gotchas listed here](../integrations/immer-middleware.md).\n\n### With optics-ts\n\nThere is another option with [optics-ts](https://github.com/akheron/optics-ts/):\n\n```ts\n  opticsInc: () =>\n    set(O.modify(O.optic<State>().path(\"deep.nested.obj.count\"))((c) => c + 1)),\n```\n\nUnlike Immer, optics-ts doesn't use proxies or mutation syntax.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/updating-state.md","loc":{"lines":{"from":101,"to":126}}}}],["90",{"pageContent":"With Ramda\n\nYou can also use [Ramda](https://ramdajs.com/):\n\n```ts\n  ramdaInc: () =>\n    set(R.over(R.lensPath([\"deep\", \"nested\", \"obj\", \"count\"]), (c) => c + 1)),\n```\n\nBoth ramda and optics-ts also work with types.\n\n### CodeSandbox Demo\n\nhttps://codesandbox.io/s/zustand-normal-immer-optics-ramda-updating-ynn3o?file=/src/App.tsx","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/guides/updating-state.md","loc":{"lines":{"from":128,"to":141}}}}],["91",{"pageContent":"---\ntitle: Immer middleware\nnav: 16\n---\n\nThe [Immer](https://github.com/immerjs/immer) middleware enables you\nto use immutable state in a more convenient way.\nAlso, with Immer, you can simplify handling\nimmutable data structures in Zustand.\n\n## Installation\n\nIn order to use the Immer middleware in Zustand,\nyou will need to install Immer as a direct dependency.\n\n```bash\nnpm install immer\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/immer-middleware.md","loc":{"lines":{"from":1,"to":18}}}}],["92",{"pageContent":"Usage\n\nUpdating simple states\n\n```ts\nimport { create } from 'zustand'\nimport { immer } from 'zustand/middleware/immer'\n\ntype State = {\n  count: number\n}\n\ntype Actions = {\n  increment: (qty: number) => void\n  decrement: (qty: number) => void\n}\n\nexport const useCountStore = create(\n  immer<State & Actions>((set) => ({\n    count: 0,\n    increment: (qty: number) =>\n      set((state) => {\n        state.count += qty\n      }),\n    decrement: (qty: number) =>\n      set((state) => {\n        state.count -= qty\n      }),\n  }))\n)","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/immer-middleware.md","loc":{"lines":{"from":20,"to":49}}}}],["93",{"pageContent":"Updating complex states\n\n```ts\nimport { create } from 'zustand'\nimport { immer } from 'zustand/middleware/immer'\n\ninterface Todo {\n  id: string\n  title: string\n  done: boolean\n}\n\ntype State = {\n  todos: Record<string, Todo>\n}\n\ntype Actions = {\n  toggleTodo: (todoId: string) => void\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/immer-middleware.md","loc":{"lines":{"from":52,"to":70}}}}],["94",{"pageContent":"type State = {\n  todos: Record<string, Todo>\n}\n\ntype Actions = {\n  toggleTodo: (todoId: string) => void\n}\n\nexport const useTodoStore = create(\n  immer<State & Actions>((set) => ({\n    todos: {\n      '82471c5f-4207-4b1d-abcb-b98547e01a3e': {\n        id: '82471c5f-4207-4b1d-abcb-b98547e01a3e',\n        title: 'Learn Zustand',\n        done: false,\n      },\n      '354ee16c-bfdd-44d3-afa9-e93679bda367': {\n        id: '354ee16c-bfdd-44d3-afa9-e93679bda367',\n        title: 'Learn Jotai',\n        done: false,\n      },\n      '771c85c5-46ea-4a11-8fed-36cc2c7be344': {\n        id: '771c85c5-46ea-4a11-8fed-36cc2c7be344',\n        title: 'Learn Valtio',\n        done: false,\n      },\n      '363a4bac-083f-47f7-a0a2-aeeee153a99c': {\n        id: '363a4bac-083f-47f7-a0a2-aeeee153a99c',\n        title: 'Learn Signals',\n        done: false,\n      },\n    },\n    toggleTodo: (todoId: string) =>\n      set((state) => {\n        state.todos[todoId].done = !state.todos[todoId].done\n      }),\n  }))\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/immer-middleware.md","loc":{"lines":{"from":70,"to":108}}}}],["95",{"pageContent":"Gotchas\n\nIn this section you will find some things\nthat you need to keep in mind when using Zustand with Immer.\n\n### My subscriptions aren't being called\n\nIf you are using Immer,\nmake sure you are actually following\n[the rules of Immer](https://immerjs.github.io/immer/pitfalls).\n\nFor example, you have to add `[immerable] = true` for\n[class objects](https://immerjs.github.io/immer/complex-objects) to work.\nIf you don't do this, Immer will still mutate the object,\nbut not as a proxy, so it will also update the current state.\nZustand checks if the state has actually changed,\nso since both the current state and the next state are\nequal (if you don't do it correctly),\nZustand will skip calling the subscriptions.\n\n## CodeSandbox Demo\n\n- [Basic](https://codesandbox.io/s/zustand-updating-draft-states-basic-demo-zkp22g),\n- [Advanced](https://codesandbox.io/s/zustand-updating-draft-states-advanced-demo-3znqzk).","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/immer-middleware.md","loc":{"lines":{"from":110,"to":133}}}}],["96",{"pageContent":"---\ntitle: Persisting store data\nnav: 17\n---\n\nThe Persist middleware enables you to store\nyour Zustand state in a storage\n(e.g., `localStorage`, `AsyncStorage`, `IndexedDB`, etc.),\nthus persisting its data.\n\nNote that this middleware supports both\nsynchronous storages, like `localStorage`,\nand asynchronous storages, like `AsyncStorage`,\nbut using an asynchronous storage does come with a cost.\nSee [Hydration and asynchronous storages](#hydration-and-asynchronous-storages)\nfor more details.\n\n## Simple example\n\n```ts\nimport { create } from 'zustand'\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\nexport const useBearStore = create(\n  persist(\n    (set, get) => ({\n      bears: 0,\n      addABear: () => set({ bears: get().bears + 1 }),\n    }),\n    {\n      name: 'food-storage', // name of the item in the storage (must be unique)\n      storage: createJSONStorage(() => sessionStorage), // (optional) by default, 'localStorage' is used\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":1,"to":36}}}}],["97",{"pageContent":"Options\n\n### `name`\n\nThis is the only required option.\nThe given name is going to be the key\nused to store your Zustand state in the storage,\nso it must be unique.\n\n### `storage`\n\n> Type: `() => StateStorage`\n\nThe `StateStorage` can be imported with:\n\n```ts\nimport { StateStorage } from 'zustand/middleware'\n```\n\n> Default: `createJSONStorage(() => localStorage)`\n\nEnables you to use your own storage.\nSimply pass a function that returns the storage you want to use.\n\nExample:\n\n```ts\nimport { persist, createJSONStorage } from 'zustand/middleware'\n\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      // ...\n    }),\n    {\n      // ...\n      storage: createJSONStorage(() => AsyncStorage),\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":38,"to":78}}}}],["98",{"pageContent":"`partialize`\n\n> Type: `(state: Object) => Object`\n\n> Default: `(state) => state`\n\nEnables you to pick some of the state's fields to be stored in the storage.\n\nYou could omit multiple fields using the following:\n\n```ts\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      foo: 0,\n      bar: 1,\n    }),\n    {\n      // ...\n      partialize: (state) =>\n        Object.fromEntries(\n          Object.entries(state).filter(([key]) => !['foo'].includes(key))\n        ),\n    }\n  )\n)\n```\n\nOr you could allow only specific fields using the following:\n\n```ts\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      foo: 0,\n      bar: 1,\n    }),\n    {\n      // ...\n      partialize: (state) => ({ foo: state.foo }),\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":80,"to":123}}}}],["99",{"pageContent":"`onRehydrateStorage`\n\n> Type: `(state: Object) => ((state?: Object, error?: Error) => void) | void`\n\nThis option enables you to pass a listener function\nthat will be called when the storage is hydrated.\n\nExample:\n\n```ts\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      // ...\n    }),\n    {\n      // ...\n      onRehydrateStorage: (state) => {\n        console.log('hydration starts')\n\n        // optional\n        return (state, error) => {\n          if (error) {\n            console.log('an error happened during hydration', error)\n          } else {\n            console.log('hydration finished')\n          }\n        }\n      },\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":125,"to":157}}}}],["100",{"pageContent":"`version`\n\n> Type: `number`\n\n> Default: `0`\n\nIf you want to introduce a breaking change in your storage\n(e.g. renaming a field), you can specify a new version number.\nBy default, if the version in the storage\ndoes not match the version in the code,\nthe stored value won't be used.\nYou can use the [migrate](#migrate) function (see below)\nto handle breaking changes in order to persist previously stored data.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":159,"to":171}}}}],["101",{"pageContent":"`migrate`\n\n> Type: `(persistedState: Object, version: number) => Object | Promise<Object>`\n\n> Default: `(persistedState) => persistedState`\n\nYou can use this option to handle versions migration.\nThe migrate function takes the persisted state\nand the version number as arguments.\nIt must return a state that is compliant\nto the latest version (the version in the code).\n\nFor instance, if you want to rename a field, you can use the following:\n\n```ts\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      newField: 0, // let's say this field was named otherwise in version 0\n    }),\n    {\n      // ...\n      version: 1, // a migration will be triggered if the version in the storage mismatches this one\n      migrate: (persistedState, version) => {\n        if (version === 0) {\n          // if the stored value is in version 0, we rename the field to the new name\n          persistedState.newField = persistedState.oldField\n          delete persistedState.oldField\n        }","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":173,"to":201}}}}],["102",{"pageContent":"return persistedState\n      },\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":203,"to":208}}}}],["103",{"pageContent":"`merge`\n\n> Type: `(persistedState: Object, currentState: Object) => Object`\n\n> Default: `(persistedState, currentState) => ({ ...currentState, ...persistedState })`\n\nIn some cases, you might want to use a custom merge function\nto merge the persisted value with the current state.\n\nBy default, the middleware does a shallow merge.\nThe shallow merge might not be enough\nif you have partially persisted nested objects.\nFor instance, if the storage contains the following:\n\n```ts\n{\n  foo: {\n    bar: 0,\n  }\n}\n```\n\nBut your Zustand store contains:\n\n```ts\n{\n  foo: {\n    bar: 0,\n    baz: 1,\n  }\n}\n```\n\nThe shallow merge will erase the `baz` field from the `foo` object.\nOne way to fix this would be to give a custom deep merge function:\n\n```ts\nexport const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      foo: {\n        bar: 0,\n        baz: 1,\n      },\n    }),\n    {\n      // ...\n      merge: (persistedState, currentState) =>\n        deepMerge(currentState, persistedState),\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":210,"to":262}}}}],["104",{"pageContent":"`skipHydration`\n\n> Type: `boolean | undefined`\n\n> Default: `undefined`\n\nBy default the store with be hydrated on initialization.\n\nIn some applications you may need to control when the first hydration occurs.\nFor example, in server-rendered apps.\n\nIf you set `skipHydration`, the initial call for hydration isn't called,\nand it is left up to you to manually call `rehydrate()`.\n\n```ts\nexport const useBoundStore = create(\n  persist(\n    () => ({\n      count: 0,\n      // ...\n    }),\n    {\n      // ...\n      skipHydration: true,\n    }\n  )\n)\n```\n\n```tsx\nimport { useBoundStore } from './path-to-store';\n\nexport function StoreConsumer() {\n  // hydrate persisted store after on mount\n  useEffect(() => {\n    useBoundStore.persist.rehydrate();\n  }, [])\n\n  return (\n    //...\n  )\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":264,"to":306}}}}],["105",{"pageContent":"API\n\n> Version: >=3.6.3\n\nThe Persist API enables you to do a number of interactions\nwith the Persist middleware\nfrom inside or outside of a React component.\n\n### `getOptions`\n\n> Type: `() => Partial<PersistOptions>`\n\n> Returns: Options of the Persist middleware\n\nFor example, it can be used to obtain the storage name:\n\n```ts\nuseBoundStore.persist.getOptions().name\n```\n\n### `setOptions`\n\n> Type: `(newOptions: Partial<PersistOptions>) => void`\n\nChanges the middleware options.\nNote that the new options will be merged with the current ones.\n\nFor instance, this can be used to change the storage name:\n\n```ts\nuseBoundStore.persist.setOptions({\n  name: 'new-name',\n})\n```\n\nOr even to change the storage engine:\n\n```ts\nuseBoundStore.persist.setOptions({\n  storage: createJSONStorage(() => sessionStorage),\n})\n```\n\n### `clearStorage`\n\n> Type: `() => void`\n\nClears everything stored under the [name](#name) key.\n\n```ts\nuseBoundStore.persist.clearStorage()\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":308,"to":359}}}}],["106",{"pageContent":"`clearStorage`\n\n> Type: `() => void`\n\nClears everything stored under the [name](#name) key.\n\n```ts\nuseBoundStore.persist.clearStorage()\n```\n\n### `rehydrate`\n\n> Type: `() => Promise<void>`\n\nIn some cases, you might want to trigger the rehydration manually.\nThis can be done by calling the `rehydrate` method.\n\n```ts\nawait useBoundStore.persist.rehydrate()\n```\n\n### `hasHydrated`\n\n> Type: `() => boolean`\n\nThis is a non-reactive getter to check\nif the storage has been hydrated\n(note that it updates when calling [`rehydrate`](#rehydrate)).\n\n```ts\nuseBoundStore.persist.hasHydrated()\n```\n\n### `onHydrate`\n\n> Type: `(listener: (state) => void) => () => void`\n\n> Returns: Unsubscribe function\n\nThis listener will be called when the hydration process starts.\n\n```ts\nconst unsub = useBoundStore.persist.onHydrate((state) => {\n  console.log('hydration starts')\n})\n\n// later on...\nunsub()\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":359,"to":407}}}}],["107",{"pageContent":"`onFinishHydration`\n\n> Type: `(listener: (state) => void) => () => void`\n\n> Returns: Unsubscribe function\n\nThis listener will be called when the hydration process ends.\n\n```ts\nconst unsub = useBoundStore.persist.onFinishHydration((state) => {\n  console.log('hydration finished')\n})\n\n// later on...\nunsub()\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":409,"to":424}}}}],["108",{"pageContent":"Hydration and asynchronous storages\n\nTo explain what is the \"cost\" of asynchronous storages,\nyou need to understand what is hydration.\n\nIn a nutshell, hydration is a process\nof retrieving persisted state from the storage\nand merging it with the current state.\n\nThe Persist middleware does two kinds of hydration:\nsynchronous and asynchronous.\nIf the given storage is synchronous (e.g., `localStorage`),\nhydration will be done synchronously.\nOn the other hand, if the given storage is asynchronous (e.g., `AsyncStorage`),\nhydration will be done asynchronously (shocking, I know!).\n\nBut what's the catch?\nWith synchronous hydration,\nthe Zustand store will already have been hydrated at its creation.\nIn contrast, with asynchronous hydration,\nthe Zustand store will be hydrated later on, in a microtask.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":426,"to":446}}}}],["109",{"pageContent":"Why does it matter?\nAsynchronous hydration can cause some unexpected behaviors.\nFor instance, if you use Zustand in a React app,\nthe store will **not** be hydrated at the initial render.\nIn cases where your app depends on the persisted value at page load,\nyou might want to wait until\nthe store has been hydrated before showing anything.\nFor example, your app might think the user\nis not logged in because it's the default,\nbut in reality the store has not been hydrated yet.\n\nIf your app does depends on the persisted state at page load,\nsee [_How can I check if my store has been hydrated_](#how-can-i-check-if-my-store-has-been-hydrated)\nin the [FAQ](#faq) section below.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":448,"to":461}}}}],["110",{"pageContent":"FAQ","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":461,"to":461}}}}],["111",{"pageContent":"How can I check if my store has been hydrated\n\nThere are a few different ways to do this.\n\nYou can use the [`onRehydrateStorage`](#onrehydratestorage)\nlistener function to update a field in the store:\n\n```ts\nconst useBoundStore = create(\n  persist(\n    (set, get) => ({\n      // ...\n      _hasHydrated: false,\n      setHasHydrated: (state) => {\n        set({\n          _hasHydrated: state\n        });\n      }\n    }),\n    {\n      // ...\n      onRehydrateStorage: () => (state) => {\n        state.setHasHydrated(true)\n      }\n    }\n  )\n);\n\nexport default function App() {\n  const hasHydrated = useBoundStore(state => state._hasHydrated);\n\n  if (!hasHydrated) {\n    return <p>Loading...</p>\n  }\n\n  return (\n    // ...\n  );\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":465,"to":503}}}}],["112",{"pageContent":"You can also create a custom `useHydration` hook:\n\n```ts\nconst useBoundStore = create(persist(...))\n\nconst useHydration = () => {\n  const [hydrated, setHydrated] = useState(useBoundStore.persist.hasHydrated)\n\n  useEffect(() => {\n    // Note: This is just in case you want to take into account manual rehydration.\n    // You can remove the following line if you don't need it.\n    const unsubHydrate = useBoundStore.persist.onHydrate(() => setHydrated(false))\n\n    const unsubFinishHydration = useBoundStore.persist.onFinishHydration(() => setHydrated(true))\n\n    setHydrated(useBoundStore.persist.hasHydrated())\n\n    return () => {\n      unsubHydrate()\n      unsubFinishHydration()\n    }\n  }, [])\n\n  return hydrated\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":506,"to":531}}}}],["113",{"pageContent":"How can I use a custom storage engine\n\nIf the storage you want to use does not match the expected API, you can create your own storage:\n\n```ts\nimport { create } from 'zustand'\nimport { persist, createJSONStorage, StateStorage } from 'zustand/middleware'\nimport { get, set, del } from 'idb-keyval' // can use anything: IndexedDB, Ionic Storage, etc.\n\n// Custom storage object\nconst storage: StateStorage = {\n  getItem: async (name: string): Promise<string | null> => {\n    console.log(name, 'has been retrieved')\n    return (await get(name)) || null\n  },\n  setItem: async (name: string, value: string): Promise<void> => {\n    console.log(name, 'with value', value, 'has been saved')\n    await set(name, value)\n  },\n  removeItem: async (name: string): Promise<void> => {\n    console.log(name, 'has been deleted')\n    await del(name)\n  },\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":533,"to":556}}}}],["114",{"pageContent":"export const useBoundStore = create(\n  persist(\n    (set, get) => ({\n      bears: 0,\n      addABear: () => set({ bears: get().bears + 1 }),\n    }),\n    {\n      name: 'food-storage', // unique name\n      storage: createJSONStorage(() => storage),\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":558,"to":570}}}}],["115",{"pageContent":"How can I rehydrate on storage event\n\nYou can use the Persist API to create your own implementation,\nsimilar to the example below:\n\n```ts\ntype StoreWithPersist = Mutate<StoreApi<State>, [[\"zustand/persist\", unknown]]>\n\nexport const withStorageDOMEvents = (store: StoreWithPersist) => {\n  const storageEventCallback = (e: StorageEvent) => {\n    if (e.key === store.persist.getOptions().name && e.newValue) {\n      store.persist.rehydrate()\n    }\n  }\n\n  window.addEventListener('storage', storageEventCallback)\n\n  return () => {\n    window.removeEventListener('storage', storageEventCallback)\n  }\n}\n\nconst useBoundStore = create(persist(...))\nwithStorageDOMEvents(useBoundStore)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":572,"to":596}}}}],["116",{"pageContent":"How do I use it with TypeScript\n\nBasic typescript usage doesn't require anything special\nexcept for writing `create<State>()(...)` instead of `create(...)`.\n\n```tsx\nimport { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\n\ninterface MyState {\n  bears: number\n  addABear: () => void\n}\n\nexport const useBearStore = create<MyState>()(\n  persist(\n    (set, get) => ({\n      bears: 0,\n      addABear: () => set({ bears: get().bears + 1 }),\n    }),\n    {\n      name: 'food-storage', // name of item in the storage (must be unique)\n      storage: createJSONStorage(() => sessionStorage), // (optional) by default the 'localStorage' is used\n      partialize: (state) => ({ bears: state.bears }),\n    }\n  )\n)\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":598,"to":625}}}}],["117",{"pageContent":"How do I use it with Map and Set\n\nWith the previous persist API, you would use `serialize`/`deserialize`\nto deal with `Map` and `Set` and convert them into\nan Array so they could be parsed into proper JSON.\n\nThe new persist API has deprecated `serialize`/`deserialize`.\n\nNow, you will need to use the `storage` prop.\nLet's say your state uses `Map` to handle a list of `transactions`,\nthen you can convert the Map into an Array in the storage prop:","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":627,"to":637}}}}],["118",{"pageContent":"Now, you will need to use the `storage` prop.\nLet's say your state uses `Map` to handle a list of `transactions`,\nthen you can convert the Map into an Array in the storage prop:\n\n```ts\n  storage: {\n    getItem: (name) => {\n      const str = localStorage.getItem(name)\n      return {\n        state: {\n          ...JSON.parse(str).state,\n          transactions: new Map(JSON.parse(str).state.transactions),\n        },\n      }\n    },\n    setItem: (name, newValue) => {\n      const str = JSON.stringify({\n        state: {\n          ...newValue.state,\n          transactions: Array.from(newValue.state.transactions.entries()),\n        },\n      })\n      localStorage.setItem(name, str)\n    },\n    removeItem: (name) => localStorage.removeItem(name),\n  },\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/persisting-store-data.md","loc":{"lines":{"from":637,"to":663}}}}],["119",{"pageContent":"---\ntitle: Third-party Libraries\nnav: 16\n---\n\nZustand provides bear necessities for state management.\nAlthough it is great for most projects,\nsome users wish to extend the library's feature set.\nThis can be done using third-party libraries created by the community.\n\n> Disclaimer: These libraries may have bugs, limited maintenance,\n> or other limitations, and are not officially recommended\n> by pmndrs or the Zustand maintainers.\n> This list aims to provide a good starting point\n> for someone looking to extend Zustand's feature set.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/third-party-libraries.md","loc":{"lines":{"from":1,"to":15}}}}],["120",{"pageContent":"- [@colorfy-software/zfy](https://colorfy-software.gitbook.io/zfy/) — 🧸 Useful helpers for state management in React with Zustand.\n- [@dhmk/zustand-lens](https://github.com/dhmk083/dhmk-zustand-lens) — Lens support for Zustand.\n- [@liveblocks/zustand](https://github.com/liveblocks/liveblocks/tree/main/packages/liveblocks-zustand) — Liveblocks middleware to make your application multiplayer.\n- [auto-zustand-selectors-hook](https://github.com/Albert-Gao/auto-zustand-selectors-hook) — Automatic generation of Zustand hooks with Typescript support.\n- [derive-zustand](https://github.com/dai-shi/derive-zustand) — A function to create a derived Zustand store from other Zustand stores.\n- [geschichte](https://github.com/BowlingX/geschichte) — Zustand and Immer-based hook to manage query parameters.\n- [mobz](https://github.com/2A5F/Mobz) — Zustand-style MobX API.\n- [ngx-zustand](https://github.com/JoaoPauloLousada/ngx-zustand) - A Zustand adapter for Angular.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/third-party-libraries.md","loc":{"lines":{"from":17,"to":24}}}}],["121",{"pageContent":"- [mobz](https://github.com/2A5F/Mobz) — Zustand-style MobX API.\n- [ngx-zustand](https://github.com/JoaoPauloLousada/ngx-zustand) - A Zustand adapter for Angular.\n- [shared-zustand](https://github.com/Tom-Julux/shared-zustand) — Cross-tab state sharing for Zustand.\n- [simple-zustand-devtools](https://github.com/beerose/simple-zustand-devtools) — 🐻⚛️ Inspect your Zustand store in React DevTools.\n- [solid-zustand](https://github.com/wobsoriano/solid-zustand) — State management in Solid using Zustand.\n- [use-zustand](https://github.com/dai-shi/use-zustand) — Another custom hook to use Zustand vanilla store.\n- [vue-zustand](https://github.com/wobsoriano/vue-zustand) — State management solution for Vue based on Zustand.\n- [zoov](https://github.com/InfiniteXyy/zoov) — State management solution based on Zustand with Module-like API.\n- [zundo](https://github.com/charkour/zundo) — 🍜 Undo and redo middleware for Zustand, enabling time-travel in your apps.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/third-party-libraries.md","loc":{"lines":{"from":24,"to":32}}}}],["122",{"pageContent":"- [zundo](https://github.com/charkour/zundo) — 🍜 Undo and redo middleware for Zustand, enabling time-travel in your apps.\n- [zukeeper](https://github.com/oslabs-beta/Zukeeper) - Native devtools with state and action tracking, diffing, tree display, and time travel\n- [zustand-constate](https://github.com/ntvinhit/zustand-constate) — Context-based state management based on Zustand and taking ideas from Constate.\n- [zustand-computed](https://github.com/chrisvander/zustand-computed) — A Zustand middleware to create computed states.\n- [zustand-di](https://github.com/charkour/zustand-di) - use react props to init zustand stores\n- [zustand-forms](https://github.com/Conduct/zustand-forms) — Fast, type safe form states as Zustand stores.\n- [zustand-middleware-computed-state](https://github.com/cmlarsen/zustand-middleware-computed-state) — A dead simple middleware for adding computed state to Zustand.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/third-party-libraries.md","loc":{"lines":{"from":32,"to":38}}}}],["123",{"pageContent":"- [zustand-middleware-computed-state](https://github.com/cmlarsen/zustand-middleware-computed-state) — A dead simple middleware for adding computed state to Zustand.\n- [zustand-middleware-xstate](https://github.com/biowaffeln/zustand-middleware-xstate) — A middleware for putting XState state machines into a global Zustand store.\n- [zustand-middleware-yjs](https://github.com/joebobmiles/zustand-middleware-yjs) — A middleware for synchronizing Zustand stores with Yjs.\n- [zustand-persist](https://github.com/roadmanfong/zustand-persist) — A middleware for persisting and rehydrating state.\n- [zustand-pub](https://github.com/AwesomeDevin/zustand-pub) - Cross-Application/Cross-Framework State Management And Sharing based on zustand and zustand-vue for React/Vue.\n- [zustand-querystring](https://github.com/nitedani/zustand-querystring) — A Zustand middleware that syncs the store with the querystring.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/third-party-libraries.md","loc":{"lines":{"from":38,"to":43}}}}],["124",{"pageContent":"- [zustand-querystring](https://github.com/nitedani/zustand-querystring) — A Zustand middleware that syncs the store with the querystring.\n- [zustand-rx](https://github.com/patdx/zustand-rx) — A Zustand middleware enabling you to subscribe to a store as an RxJS Observable.\n- [zustand-saga](https://github.com/Nowsta/zustand-saga) — A Zustand middleware for redux-saga (minus redux).\n- [zustand-store-addons](https://github.com/Diablow/zustand-store-addons) — React state management addons for Zustand.\n- [zustand-vue](https://github.com/AwesomeDevin/zustand-vue) - State management for vue (Vue3 / Vue2) based on zustand.\n- [zustand-yjs](https://github.com/tandem-pt/zustand-yjs) — Zustand stores for Yjs structures.\n- [zusteller](https://github.com/timkindberg/zusteller) — Your global state savior. \"Just hooks\" + Zustand.\n- [zustood](https://github.com/udecode/zustood) — 🐻‍❄️ A modular store factory using Zustand.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/integrations/third-party-libraries.md","loc":{"lines":{"from":43,"to":50}}}}],["125",{"pageContent":"---\ntitle: Migrating to v4\nnav: 19\n---\n\nThe only breaking changes are in types.\nIf you are using Zustand with TypeScript\nor JSDoc type annotations,\nthis guide applies.\nOtherwise, no migration is required.\n\nAlso, it's recommended to first read\nthe new [TypeScript Guide](../guides/typescript.md),\nso that the migration is easier to understand.\n\nIn addition to this migration guide,\nyou can also check the\n[diff](https://github.com/pmndrs/zustand/compare/v3.7.2...v4.0.0?short_path=37e5b4c#diff-c21e24854115b390eccde717da83f91feb2d5927a76c1485e5f0fdd0135c2afa)\nof the test files in the Zustand repository from v3 to v4.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":1,"to":19}}}}],["126",{"pageContent":"`create`\n\n**Applicable imports**\n\n```ts\nimport create from 'zustand'\nimport create from 'zustand/vanilla'\n```\n\n**Change**\n\n```diff\n- create:\n-   < State\n-   , StoreSetState = StoreApi<State>[\"set\"]\n-   , StoreGetState = StoreApi<State>[\"get\"]\n-   , Store = StoreApi<State>\n-   >\n-     (f: ...) => ...\n+ create:\n+   { <State>(): (f: ...) => ...\n+   , <State, Mutators>(f: ...) => ...\n+   }\n```\n\n**Migration**\n\nIf you are not passing any type parameters to `create`,\nno migration is required.\n\nIf you are using a \"leaf\" middleware like `combine` or `redux`,\nremove all type parameters from `create`.\n\nElse, replace `create<T, ...>(...)` with `create<T>()(...)`.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":21,"to":54}}}}],["127",{"pageContent":"`StateCreator`\n\n**Applicable imports**\n\n```ts\nimport type { StateCreator } from 'zustand'\nimport type { StateCreator } from 'zustand/vanilla'\n```\n\n**Change**\n\n```diff\n- type StateCreator\n-   < State\n-   , StoreSetState = StoreApi<State>[\"set\"]\n-   , StoreGetState = StoreApi<State>[\"get\"]\n-   , Store = StoreApi<State>\n-   > =\n-     ...\n+ type StateCreator\n+   < State\n+   , InMutators extends [StoreMutatorIdentifier, unknown][] = []\n+   , OutMutators extends [StoreMutatorIdentifier, unknown][] = []\n+   , Return = State\n+   > =\n+     ...\n```\n\n**Migration**\n\nIf you are using `StateCreator`,\nyou are likely authoring a middleware\nor using the \"slices\" pattern.\nFor that check the\n[Authoring middlewares and advanced usage](../guides/typescript.md#authoring-middlewares-and-advanced-usage)\nand [Common recipes](../guides/typescript.md#common-recipes)\nsections of the TypeScript Guide.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":56,"to":92}}}}],["128",{"pageContent":"`PartialState`\n\n**Applicable imports**\n\n```ts\nimport type { PartialState } from 'zustand'\nimport type { PartialState } from 'zustand/vanilla'\n```\n\n**Change**\n\n```diff\n- type PartialState\n-   < T extends State\n-   , K1 extends keyof T = keyof T\n-   , K2 extends keyof T = K1\n-   , K3 extends keyof T = K2\n-   , K4 extends keyof T = K3\n-   > =\n-   | (Pick<T, K1> | Pick<T, K2> | Pick<T, K3> | Pick<T, K4> | T)\n-   | ((state: T) => Pick<T, K1> | Pick<T, K2> | Pick<T, K3> | Pick<T, K4> | T)\n+ type PartialState<T> =\n+   | Partial<T>\n+   | ((state: T) => Partial<T>)\n```\n\n**Migration**\n\nReplace `PartialState<T, ...>` with `PartialState<T>`\nand preferably turn on [`exactOptionalPropertyTypes`](https://www.typescriptlang.org/tsconfig#exactOptionalPropertyTypes)\nin your `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"exactOptionalPropertyTypes\": true\n  }\n}","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":94,"to":131}}}}],["129",{"pageContent":"We're no longer using the trick to disallow `{ foo: undefined }`\nto be assigned to `Partial<{ foo: string }>`.\nInstead, we're relying on the users to turn on `exactOptionalPropertyTypes`.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":134,"to":136}}}}],["130",{"pageContent":"`useStore`\n\n**Applicable imports**\n\n```ts\nimport { useStore } from 'zustand'\nimport { useStore } from 'zustand/react'\n```\n\n**Change**\n\n```diff\n- useStore:\n-   { <State>(store: StoreApi<State>): State\n-   , <State, StateSlice>\n-       ( store: StoreApi<State>\n-       , selector: StateSelector<State, StateSlice>,\n-       , equals?: EqualityChecker<StateSlice>\n-       ): StateSlice\n-   }\n+ useStore:\n+   <Store, StateSlice = ExtractState<Store>>\n+     ( store: Store\n+     , selector?: StateSelector<State, StateSlice>,\n+     , equals?: EqualityChecker<StateSlice>\n+     )\n+       => StateSlice\n```\n\n**Migration**\n\nIf you are not passing any type parameters to `useStore`,\nno migration is required.\n\nIf you are,\nit's recommended to remove all the type parameters,\nor pass the **store** type instead of the **state** type as the first parameter.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":138,"to":174}}}}],["131",{"pageContent":"`UseBoundStore`\n\n**Applicable imports**\n\n```ts\nimport type { UseBoundStore } from 'zustand'\nimport type { UseBoundStore } from 'zustand/react'\n```\n\n**Change**\n\n```diff\n- type UseBoundStore<\n-   State,\n-   Store = StoreApi<State>\n- > =\n-   & { (): T\n-     , <StateSlice>\n-         ( selector: StateSelector<State, StateSlice>\n-         , equals?: EqualityChecker<StateSlice>\n-         ): U\n-     }\n-   & Store\n+ type UseBoundStore<Store> =\n+   & (<StateSlice = ExtractState<S>>\n+       ( selector?: (state: ExtractState<S>) => StateSlice\n+       , equals?: (a: StateSlice, b: StateSlice) => boolean\n+       ) => StateSlice\n+     )\n+   & S\n```\n\n**Migration**\n\nReplace `UseBoundStore<T>` with `UseBoundStore<StoreApi<T>>`,\nand `UseBoundStore<T, S>` with `UseBoundStore<S>`\n\n## `UseContextStore`\n\n**Applicable imports**\n\n```ts\nimport type { UseContextStore } from 'zustand/context'\n```\n\n**Change**\n\n```diff\n- type UseContextStore\n```\n\n**Migration**\n\nUse `typeof MyContext.useStore` instead","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":176,"to":229}}}}],["132",{"pageContent":"`createContext`\n\n**Applicable imports**\n\n```ts\nimport createContext from 'zustand/context'\n```\n\n**Change**\n\n```diff\n  createContext:\n-   <State, Store = StoreApi<State>>() => ...\n+   <Store>() => ...\n```\n\n**Migration**\n\nReplace `createContext<T>()` with `createContext<StoreApi<T>>()`,\nand `createContext<T, S>()` with `createContext<S>()`.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":231,"to":250}}}}],["133",{"pageContent":"`combine`, `devtools`, `subscribeWithSelector`\n\n**Applicable imports**\n\n```ts\nimport { combine } from 'zustand/middleware'\nimport { devtools } from 'zustand/middleware'\nimport { subscribeWithSelector } from 'zustand/middleware'\n```\n\n**Change**\n\n```diff\n- combine:\n-   <T, U>(...) => ...\n+ combine:\n+   <T, U, Mps, Mcs>(...) => ...\n\n- devtools:\n-   <T>(...) => ...\n+ devtools:\n+   <T, Mps, Mcs>(...) => ...\n\n- subscribeWithSelector:\n-   <T>(...) => ...\n+ subscribeWithSelector:\n+   <T, Mps, Mcs>(...) => ...\n```\n\n**Migration**\n\nIf you are not passing any type parameters\nto `combine`, `devtools`, or `subscribeWithSelector`,\nno migration is required.\n\nIf you are,\nremove all the type parameters,\nas they are inferred automatically.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":252,"to":289}}}}],["134",{"pageContent":"`persist`\n\n**Applicable imports**\n\n```ts\nimport { persist } from 'zustand/middleware'\n```\n\n**Change**\n\n```diff\n- persist:\n-   <T, U = Partial<T>>(...) => ...\n+ persist:\n+   <T, Mps, Mcs, U = T>(...) => ...","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":291,"to":305}}}}],["135",{"pageContent":"**Migration**\n\nIf you are passing any type parameters,\nremove them as they are inferred automatically.\n\nNext, if you are passing the `partialize` option,\nthere is no further steps required for migration.\n\nIf you are **not** passing the `partialize` option,\nyou might see some compilation errors.\nIf you do not see any,\nthere is no further migration required.\n\nThe type of partialized state is now `T` instead of `Partial<T>`,\nwhich aligns with the runtime behavior of the default `partialize`,\nwhich is an identity (`s => s`).\n\nIf you see some compilation errors,\nyou have to find and fix the errors yourself,\nbecause they might be indicative of unsound code.\nAlternatively, the workaround will be passing\n`s => s as Partial<typeof s>` to `partialize`.\nIf your partialized state is truly `Partial<T>`,\nyou should not encounter any bugs.\n\nThe runtime behavior has not changed,\nonly the types are now correct.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":308,"to":334}}}}],["136",{"pageContent":"`redux`\n\n**Applicable imports**\n\n```ts\nimport { redux } from 'zustand/middleware'\n```\n\n**Change**\n\n```diff\n- redux:\n-   <T, A>(...) => ...\n+ redux:\n+   <T, A, Mps, Mcs>(...) => ...\n```\n\n**Migration**\n\nIf you are not passing any type parameters to `redux`,\nno migration is required.\n\nIf you are,\nremove all the type parameters,\nand annotate only the second (action) parameter.\nThat is, replace `redux<T, A>((state, action) => ..., ...)`\nwith `redux((state, action: A) => ..., ...)`.","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/migrations/migrating-to-v4.md","loc":{"lines":{"from":336,"to":362}}}}],["137",{"pageContent":"---\ntitle: createContext from zustand/context\nnav: 18\n---\n\nA special `createContext` is provided since v3.5,\nwhich avoids misusing the store hook.\n\n> **Note**: This function is deprecated in v4 and will be removed in v5. See [Migration](#migration).\n\n```jsx\nimport create from 'zustand'\nimport createContext from 'zustand/context'\n\nconst { Provider, useStore } = createContext()\n\nconst createStore = () => create(...)\n\nconst App = () => (\n  <Provider createStore={createStore}>\n    ...\n  </Provider>\n)\n\nconst Component = () => {\n  const state = useStore()\n  const slice = useStore(selector)\n  ...\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/previous-versions/zustand-v3-create-context.md","loc":{"lines":{"from":1,"to":29}}}}],["138",{"pageContent":"createContext usage in real components\n\n```jsx\nimport create from \"zustand\";\nimport createContext from \"zustand/context\";\n\n// Best practice: You can move the below createContext() and createStore to a separate file(store.js) and import the Provider, useStore here/wherever you need.\n\nconst { Provider, useStore } = createContext();\n\nconst createStore = () =>\n  create((set) => ({\n    bears: 0,\n    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n    removeAllBears: () => set({ bears: 0 })\n  }));\n\nconst Button = () => {\n  return (\n      {/** store() - This will create a store for each time using the Button component instead of using one store for all components **/}\n    <Provider createStore={createStore}>\n      <ButtonChild />\n    </Provider>\n  );\n};","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/previous-versions/zustand-v3-create-context.md","loc":{"lines":{"from":31,"to":55}}}}],["139",{"pageContent":"const ButtonChild = () => {\n  const state = useStore();\n  return (\n    <div>\n      {state.bears}\n      <button\n        onClick={() => {\n          state.increasePopulation();\n        }}\n      >\n        +\n      </button>\n    </div>\n  );\n};\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <Button />\n      <Button />\n    </div>\n  );\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/previous-versions/zustand-v3-create-context.md","loc":{"lines":{"from":57,"to":81}}}}],["140",{"pageContent":"createContext usage with initialization from props\n\n```tsx\nimport create from 'zustand'\nimport createContext from 'zustand/context'\n\nconst { Provider, useStore } = createContext()\n\nexport default function App({ initialBears }) {\n  return (\n    <Provider\n      createStore={() =>\n        create((set) => ({\n          bears: initialBears,\n          increase: () => set((state) => ({ bears: state.bears + 1 })),\n        }))\n      }>\n      <Button />\n    </Provider>\n  )\n}\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/previous-versions/zustand-v3-create-context.md","loc":{"lines":{"from":83,"to":104}}}}],["141",{"pageContent":"Migration\n\nDiscussion: https://github.com/pmndrs/zustand/discussions/1276\n\nHere's the diff showing how to migrate from v3 createContext to v4 API.\n\n```diff\n// store.ts\n+ import { createContext, useContext } from \"react\";\n- import create from \"zustand\";\n- import createContext from \"zustand/context\";\n+ import { createStore, useStore } from \"zustand\";\n\n- const useStore = create((set) => ({\n+ const store =  createStore((set) => ({\n    bears: 0,\n    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),\n    removeAllBears: () => set({ bears: 0 })\n  }));\n\n+ const MyContext = createContext()\n\n+ export const Provider = ({ children }) = <MyContext.Provider value={store}>{children}</MyContext.Provider>;\n\n+ export const useMyStore = (selector) => useStore(useContext(MyContext), selector);\n```","metadata":{"source":"/Users/marcus/personal/monkeylabs/docs/previous-versions/zustand-v3-create-context.md","loc":{"lines":{"from":106,"to":131}}}}]]